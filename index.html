<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 800px;
            padding: 0 10px;
        }

        .score-display {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .attempts {
            color: #ff6b6b;
            font-size: 18px;
        }

        canvas {
            border: 3px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .controls {
            color: #aaa;
            font-size: 14px;
            text-align: center;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 10;
            display: none;
        }

        .overlay.active {
            display: block;
        }

        .overlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            animation: pulse 1.5s ease-in-out infinite;
        }

        .overlay p {
            font-size: 20px;
            color: #aaa;
            margin-bottom: 10px;
        }

        .overlay .subtitle {
            font-size: 16px;
            color: #666;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .death-overlay {
            background: rgba(255, 0, 0, 0.2);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .death-overlay.active {
            opacity: 1;
        }

        .progress-bar {
            width: 800px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            width: 0%;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="score-display">Score: <span id="score">0</span></div>
            <div class="attempts">Attempts: <span id="attempts">1</span></div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        <div style="position: relative;">
            <canvas id="gameCanvas" width="800" height="400"></canvas>
            <div class="death-overlay" id="deathOverlay"></div>
            <div class="overlay active" id="startOverlay">
                <h1>GEOMETRY DASH</h1>
                <p>Click or Press Space to Play</p>
                <p class="subtitle">Avoid the obstacles!</p>
            </div>
        </div>
        <div class="controls">
            <p>ðŸŽ® SPACE / CLICK / TAP to jump | Hold for continuous jumping</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const attemptsDisplay = document.getElementById('attempts');
        const startOverlay = document.getElementById('startOverlay');
        const deathOverlay = document.getElementById('deathOverlay');
        const progressBar = document.getElementById('progress');

        // Game constants
        const GRAVITY = 0.6;
        const JUMP_FORCE = -12;
        const GAME_SPEED = 6;
        const GROUND_HEIGHT = 60;
        const LEVEL_LENGTH = 5000;

        // Game state
        let gameState = 'start'; // start, playing, dead
        let score = 0;
        let attempts = 1;
        let cameraX = 0;
        let particles = [];
        let groundParticles = [];

        // Player
        const player = {
            x: 100,
            y: canvas.height - GROUND_HEIGHT - 40,
            width: 40,
            height: 40,
            velocityY: 0,
            rotation: 0,
            isGrounded: true,
            color: '#00ffff'
        };

        // Generate level obstacles
        let obstacles = [];
        
        function generateLevel() {
            obstacles = [];
            let x = 500;
            
            while (x < LEVEL_LENGTH) {
                const type = Math.random();
                
                if (type < 0.4) {
                    // Single spike
                    obstacles.push({
                        type: 'spike',
                        x: x,
                        y: canvas.height - GROUND_HEIGHT - 35,
                        width: 35,
                        height: 35
                    });
                    x += 200 + Math.random() * 150;
                } else if (type < 0.6) {
                    // Double spike
                    obstacles.push({
                        type: 'spike',
                        x: x,
                        y: canvas.height - GROUND_HEIGHT - 35,
                        width: 35,
                        height: 35
                    });
                    obstacles.push({
                        type: 'spike',
                        x: x + 35,
                        y: canvas.height - GROUND_HEIGHT - 35,
                        width: 35,
                        height: 35
                    });
                    x += 250 + Math.random() * 150;
                } else if (type < 0.75) {
                    // Block
                    obstacles.push({
                        type: 'block',
                        x: x,
                        y: canvas.height - GROUND_HEIGHT - 40,
                        width: 40,
                        height: 40
                    });
                    x += 200 + Math.random() * 100;
                } else if (type < 0.85) {
                    // Block with spike on top
                    obstacles.push({
                        type: 'block',
                        x: x,
                        y: canvas.height - GROUND_HEIGHT - 40,
                        width: 40,
                        height: 40
                    });
                    obstacles.push({
                        type: 'spike',
                        x: x + 2.5,
                        y: canvas.height - GROUND_HEIGHT - 75,
                        width: 35,
                        height: 35
                    });
                    x += 250 + Math.random() * 150;
                } else {
                    // Triple spike
                    for (let i = 0; i < 3; i++) {
                        obstacles.push({
                            type: 'spike',
                            x: x + i * 35,
                            y: canvas.height - GROUND_HEIGHT - 35,
                            width: 35,
                            height: 35
                        });
                    }
                    x += 300 + Math.random() * 200;
                }
            }
        }

        // Particle effects
        function createDeathParticles(x, y) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    size: Math.random() * 10 + 5,
                    color: player.color,
                    life: 1
                });
            }
        }

        function createGroundParticle() {
            if (player.isGrounded && Math.random() < 0.3) {
                groundParticles.push({
                    x: player.x - cameraX,
                    y: canvas.height - GROUND_HEIGHT,
                    vx: -2 - Math.random() * 2,
                    vy: -Math.random() * 2,
                    size: Math.random() * 4 + 2,
                    life: 1
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= 0.02;
                return p.life > 0;
            });

            groundParticles = groundParticles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - cameraX, p.y, p.size, p.size);
            });

            groundParticles.forEach(p => {
                ctx.globalAlpha = p.life * 0.5;
                ctx.fillStyle = '#888';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.globalAlpha = 1;
        }

        // Drawing functions
        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 50; i++) {
                const x = (i * 73 + cameraX * 0.1) % canvas.width;
                const y = (i * 37) % (canvas.height - GROUND_HEIGHT - 50);
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 1.5 + 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Background blocks (parallax)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
            for (let i = 0; i < 10; i++) {
                const x = ((i * 150) - (cameraX * 0.2) % 1500 + 1500) % 1500 - 150;
                const y = 50 + (i * 30) % 150;
                ctx.fillRect(x, y, 80, 80);
            }
        }

        function drawGround() {
            // Main ground
            const groundGradient = ctx.createLinearGradient(0, canvas.height - GROUND_HEIGHT, 0, canvas.height);
            groundGradient.addColorStop(0, '#2d3436');
            groundGradient.addColorStop(1, '#1a1a1a');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

            // Ground line
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - GROUND_HEIGHT);
            ctx.lineTo(canvas.width, canvas.height - GROUND_HEIGHT);
            ctx.stroke();

            // Grid pattern on ground
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 40;
            const offsetX = -cameraX % gridSize;
            
            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - GROUND_HEIGHT);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function drawPlayer() {
            ctx.save();
            const screenX = player.x - cameraX;
            const centerX = screenX + player.width / 2;
            const centerY = player.y + player.height / 2;

            ctx.translate(centerX, centerY);
            ctx.rotate(player.rotation);
            ctx.translate(-player.width / 2, -player.height / 2);

            // Glow effect
            ctx.shadowColor = player.color;
            ctx.shadowBlur = 20;

            // Main cube
            const gradient = ctx.createLinearGradient(0, 0, player.width, player.height);
            gradient.addColorStop(0, '#00ffff');
            gradient.addColorStop(1, '#0088aa');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, player.width, player.height);

            // Inner design
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(5, 5, player.width - 10, player.height - 10);

            // Eye
            ctx.fillStyle = '#fff';
            ctx.fillRect(20, 12, 14, 14);
            ctx.fillStyle = '#000';
            ctx.fillRect(26, 14, 6, 10);

            // Border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, player.width, player.height);

            ctx.restore();
        }

        function drawSpike(obstacle) {
            const x = obstacle.x - cameraX;
            const y = obstacle.y;

            ctx.save();
            ctx.shadowColor = '#ff0066';
            ctx.shadowBlur = 10;

            ctx.fillStyle = '#ff0066';
            ctx.beginPath();
            ctx.moveTo(x + obstacle.width / 2, y);
            ctx.lineTo(x + obstacle.width, y + obstacle.height);
            ctx.lineTo(x, y + obstacle.height);
            ctx.closePath();
            ctx.fill();

            // Inner triangle
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.moveTo(x + obstacle.width / 2, y + 10);
            ctx.lineTo(x + obstacle.width - 8, y + obstacle.height - 5);
            ctx.lineTo(x + 8, y + obstacle.height - 5);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawBlock(obstacle) {
            const x = obstacle.x - cameraX;
            const y = obstacle.y;

            ctx.save();
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 10;

            const gradient = ctx.createLinearGradient(x, y, x + obstacle.width, y + obstacle.height);
            gradient.addColorStop(0, '#ff6600');
            gradient.addColorStop(1, '#cc4400');
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, obstacle.width, obstacle.height);

            // Inner design
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(x + 5, y + 5, obstacle.width - 10, obstacle.height - 10);

            // Border
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, obstacle.width, obstacle.height);

            ctx.restore();
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                const screenX = obstacle.x - cameraX;
                if (screenX > -100 && screenX < canvas.width + 100) {
                    if (obstacle.type === 'spike') {
                        drawSpike(obstacle);
                    } else if (obstacle.type === 'block') {
                        drawBlock(obstacle);
                    }
                }
            });
        }

        // Collision detection
        function checkCollision() {
            const playerBox = {
                x: player.x + 5,
                y: player.y + 5,
                width: player.width - 10,
                height: player.height - 10
            };

            for (const obstacle of obstacles) {
                if (obstacle.type === 'spike') {
                    // Triangle collision (simplified)
                    const spikeCenter = obstacle.x + obstacle.width / 2;
                    const playerCenter = player.x + player.width / 2;
                    const playerBottom = player.y + player.height;
                    
                    if (playerCenter > obstacle.x + 5 && 
                        playerCenter < obstacle.x + obstacle.width - 5 &&
                        playerBottom > obstacle.y + 10 &&
                        player.y < obstacle.y + obstacle.height) {
                        return true;
                    }
                } else if (obstacle.type === 'block') {
                    if (playerBox.x < obstacle.x + obstacle.width &&
                        playerBox.x + playerBox.width > obstacle.x &&
                        playerBox.y < obstacle.y + obstacle.height &&
                        playerBox.y + playerBox.height > obstacle.y) {
                        
                        // Check if landing on top
                        const prevBottom = player.y - player.velocityY + player.height;
                        if (prevBottom <= obstacle.y + 5 && player.velocityY >= 0) {
                            player.y = obstacle.y - player.height;
                            player.velocityY = 0;
                            player.isGrounded = true;
                            return false;
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        // Game logic
        function jump() {
            if (player.isGrounded) {
                player.velocityY = JUMP_FORCE;
                player.isGrounded = false;
            }
        }

        function resetPlayer() {
            player.x = 100;
            player.y = canvas.height - GROUND_HEIGHT - player.height;
            player.velocityY = 0;
            player.rotation = 0;
            player.isGrounded = true;
            cameraX = 0;
            score = 0;
            particles = [];
            groundParticles = [];
        }

        function die() {
            gameState = 'dead';
            createDeathParticles(player.x - cameraX + player.width / 2, player.y + player.height / 2);
            deathOverlay.classList.add('active');
            
            setTimeout(() => {
                deathOverlay.classList.remove('active');
                attempts++;
                attemptsDisplay.textContent = attempts;
                resetPlayer();
                gameState = 'playing';
            }, 500);
        }

        function update() {
            if (gameState !== 'playing') return;

            // Apply gravity
            player.velocityY += GRAVITY;
            player.y += player.velocityY;

            // Ground collision
            const groundY = canvas.height - GROUND_HEIGHT - player.height;
            if (player.y >= groundY) {
                player.y = groundY;
                player.velocityY = 0;
                player.isGrounded = true;
            }

            // Rotation
            if (!player.isGrounded) {
                player.rotation += 0.15;
            } else {
                // Snap rotation to nearest 90 degrees
                const targetRotation = Math.round(player.rotation / (Math.PI / 2)) * (Math.PI / 2);
                player.rotation += (targetRotation - player.rotation) * 0.3;
            }

            // Move camera (player stays in place, world moves)
            cameraX += GAME_SPEED;
            player.x += GAME_SPEED;

            // Update score
            score = Math.floor(cameraX / 10);
            scoreDisplay.textContent = score;

            // Update progress bar
            const progress = Math.min((cameraX / LEVEL_LENGTH) * 100, 100);
            progressBar.style.width = progress + '%';

            // Check win condition
            if (cameraX >= LEVEL_LENGTH) {
                gameState = 'start';
                startOverlay.innerHTML = '<h1>LEVEL COMPLETE!</h1><p>Score: ' + score + '</p><p>Click to Play Again</p>';
                startOverlay.classList.add('active');
                generateLevel();
                return;
            }

            // Check collision
            if (checkCollision()) {
                die();
                return;
            }

            // Create ground particles
            createGroundParticle();
            updateParticles();
        }

        function draw() {
            drawBackground();
            drawGround();
            drawObstacles();
            drawPlayer();
            drawParticles();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Input handling
        let isHolding = false;

        function handleInput() {
            if (gameState === 'start') {
                gameState = 'playing';
                startOverlay.classList.remove('active');
                startOverlay.innerHTML = '<h1>GEOMETRY DASH</h1><p>Click or Press Space to Play</p><p class="subtitle">Avoid the obstacles!</p>';
                resetPlayer();
            } else if (gameState === 'playing') {
                jump();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                if (!isHolding) {
                    handleInput();
                }
                isHolding = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                isHolding = false;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleInput();
            isHolding = true;
        });

        canvas.addEventListener('mouseup', () => {
            isHolding = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
            isHolding = true;
        });

        canvas.addEventListener('touchend', () => {
            isHolding = false;
        });

        // Continuous jump when holding
        setInterval(() => {
            if (isHolding && gameState === 'playing') {
                jump();
            }
        }, 50);

        // Initialize
        generateLevel();
        gameLoop();
    </script>
</body>
</html>
